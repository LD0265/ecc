mod allocator;

// Expect to see a lot of comments here
// This might just be the messiest file
// But that's fine because I'm awesome

use crate::{
    error::CompileError,
    mips::allocator::Allocator,
    parser::ast::{DataStorageType, Expr, Program, Statement, Type},
};

pub struct MipsGenerator {
    program: Program,
    generated: String,
}

impl MipsGenerator {
    pub fn new(program: Program) -> Self {
        MipsGenerator {
            program,
            generated: String::new(),
        }
    }

    pub fn generate(&mut self) -> Result<&String, CompileError> {
        // This feels hacky
        if !self.check_if_main_exists() {
            return Err(CompileError::CodeGenError {
                message: "No main function found".to_string(),
                line: 0,
            });
        }

        self.emit("# Assembly generated by ecc (Evil C Compiler)\n");

        let data_segment_body = self.program.segments.data.body.clone();
        let text_segment_body = self.program.segments.text.body.clone();

        if data_segment_body.len() > 0 {
            self.emit(".data");
        }

        for stmt in &data_segment_body {
            self.generate_data_label(stmt);
        }

        if text_segment_body.len() > 0 {
            self.emit(".text");
            self.emit(".globl _start\n");
        }

        for stmt in &text_segment_body {
            match stmt {
                Statement::Function { .. } => self.generate_function(stmt),
                _ => {}
            }
        }

        Ok(&self.generated)
    }

    fn emit(&mut self, line: &str) {
        self.generated.push_str(line);
        self.generated.push_str("\n");
    }

    // {:<8} alligns the operands
    fn emit_instruction(&mut self, opcode: &str, operands: &str) {
        self.generated
            .push_str(&format!("        {:<8}{}\n", opcode, operands));
    }

    fn emit_label(&mut self, label: &str) {
        self.generated.push_str(label);
        self.generated.push_str(":\n");
    }

    fn check_if_main_exists(&self) -> bool {
        for stmt in &self.program.segments.text.body {
            if let Statement::Function { name, .. } = stmt {
                if name == "main" {
                    return true;
                }
            }
        }

        false
    }

    fn generate_function(&mut self, function: &Statement) {
        if let Statement::Function {
            name,
            params,
            body,
            return_type,
            use_stack,
        } = function
        {
            if *use_stack {
                // Each function get its own allocator with its own stack frame
                let allocator = &mut Allocator::new();

                let stack_size = allocator.calculate_needed_stack_space(&body);

                self.emit_label(name);

                self.emit_instruction("addi", &format!("$sp, $sp, -{}", stack_size));
                allocator.add_stack_variable("$ra");

                // It's okay to unwrap here because we just added $ra
                self.emit_instruction(
                    "sw",
                    &format!(
                        "$ra, {}($sp)\n",
                        allocator.get_stack_variable_offset("$ra").unwrap()
                    ),
                );

                for stmt in body {
                    self.generate_statement(&stmt, allocator);
                }

                self.emit_instruction(
                    "lw",
                    &format!(
                        "$ra, {}($sp)",
                        allocator.get_stack_variable_offset("$ra").unwrap()
                    ),
                );

                self.emit_instruction("addi", &format!("$sp, $sp, {}\n", stack_size));
                self.emit_instruction("jr", "$ra\n");
            } else {
                self.emit_label(name);

                for stmt in body {
                    self.generate_statement(&stmt, &mut Allocator::new());
                }
            }
        }
    }

    fn generate_statement(&mut self, statement: &Statement, allocator: &mut Allocator) {
        match statement {
            Statement::VariableDeclaration {
                var_type,
                identifier,
                init,
            } => self.generate_variable_declaration(var_type, identifier, init, allocator),

            Statement::Instruction { opcode, operands } => {
                self.emit_instruction(opcode, &operands.join(", "));
            }

            _ => {}
        }
    }

    // This function is a mess, so be careful
    // You might hurt your eyes reading it
    fn generate_variable_declaration(
        &mut self,
        var_type: &Type,
        identifier: &String,
        init: &Option<Expr>,
        allocator: &mut Allocator,
    ) {
        allocator.add_stack_variable(identifier);

        if let Some(expr) = init {
            let reg = match allocator.allocate_temp() {
                Some(r) => r,
                None => {
                    panic!("Ran out of temporary registers");
                }
            };

            match var_type {
                Type::Int32 => match expr {
                    Expr::Integer(value) => {
                        self.emit_instruction("li", &format!("{}, {}", reg.to_string(), value));

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                reg.to_string(),
                                allocator.get_stack_variable_offset(identifier).unwrap()
                            ),
                        );

                        allocator.free_temp(reg);
                    }

                    Expr::Identifier(name) => {
                        let offset = match allocator.get_stack_variable_offset(name) {
                            Some(n) => n,
                            None => {
                                panic!("Variable {} not found in stack", name);
                            }
                        };

                        self.emit_instruction(
                            "lw",
                            &format!("{}, {}($sp)", reg.to_string(), offset),
                        );

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                reg.to_string(),
                                allocator.get_stack_variable_offset(identifier).unwrap()
                            ),
                        );

                        allocator.free_temp(reg);
                    }

                    _ => {
                        CompileError::TypeError {
                            message: "Unsupported expression in variable initialization"
                                .to_string(),
                            line: 0,
                        };
                    }
                },

                Type::String => match expr {
                    Expr::StringLiteral(str) => {
                        let label = match self.get_data_label_for_string(str) {
                            Some(l) => l,
                            None => {
                                panic!("String literal {} not found in data segment", str);
                            }
                        };

                        self.emit_instruction("la", &format!("{}, {}", reg.to_string(), label));

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                reg.to_string(),
                                allocator.get_stack_variable_offset(identifier).unwrap()
                            ),
                        );

                        allocator.free_temp(reg);
                    }
                    
                    Expr::Identifier(name) => {
                        let offset = match allocator.get_stack_variable_offset(name) {
                            Some(n) => n,
                            None => {
                                panic!("Variable {} not found in stack", name);
                            }
                        };

                        self.emit_instruction(
                            "lw",
                            &format!("{}, {}($sp)", reg.to_string(), offset),
                        );

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                reg.to_string(),
                                allocator.get_stack_variable_offset(identifier).unwrap()
                            ),
                        );

                        allocator.free_temp(reg);
                    }

                    _ => {
                        CompileError::TypeError {
                            message: "Unsupported expression in variable initialization"
                                .to_string(),
                            line: 0,
                        };
                    }
                },

                _ => {}
            }
        }
    }

    fn generate_data_label(&mut self, statement: &Statement) {
        if let Statement::DataDeclaration {
            label,
            storage_type,
            value,
        } = statement
        {
            match storage_type {
                DataStorageType::Asciiz => {
                    self.emit(&format!("\t{}: .asciiz \"{}\"", label, value));
                }
            }
        }

        self.emit("");
    }

    fn get_data_label_for_string(&self, value: &String) -> Option<String> {
        for stmt in &self.program.segments.data.body {
            if let Statement::DataDeclaration {
                label,
                storage_type: DataStorageType::Asciiz,
                value: val,
            } = stmt
            {
                if val == value {
                    return Some(label.clone());
                }
            }
        }

        None
    }
}
