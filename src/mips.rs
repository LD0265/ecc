mod allocator;

// Expect to see a lot of comments here
// This might just be the messiest file
// But that's fine because I'm awesome

use crate::{
    error::CompileError,
    mips::allocator::{Allocator, VariableLocation},
    parser::ast::{
        Argument, BinaryOperator, BuiltinFunctionType, DataStorageType, Expr, Program, Statement,
        Type,
    },
};

pub struct MipsGenerator {
    program: Program,
    generated: String,
    line: usize,
    emit_comments: bool,
}

impl MipsGenerator {
    pub fn new(program: Program, emit_comments: bool) -> Self {
        MipsGenerator {
            program,
            generated: String::new(),
            line: 1,
            emit_comments,
        }
    }

    pub fn generate(&mut self) -> Result<&String, CompileError> {
        // This feels hacky
        if !self.check_if_main_exists() {
            return Err(CompileError::CodeGenError {
                message: "No main function found".to_string(),
                line: self.line,
            });
        }

        self.emit("# Assembly generated by ecc (Evil C Compiler)\n");

        let data_segment_body = self.program.segments.data.body.clone();
        let text_segment_body = self.program.segments.text.body.clone();

        if data_segment_body.len() > 0 {
            self.emit(".data");
        }

        for stmt in &data_segment_body {
            self.generate_data_label(stmt);
        }

        self.emit("");

        if text_segment_body.len() > 0 {
            self.emit(".text");
            self.emit(".globl _start\n");
        }

        for stmt in &text_segment_body {
            match stmt {
                Statement::Function { .. } => self.generate_function(stmt),
                _ => {}
            }
        }

        Ok(&self.generated)
    }

    fn emit(&mut self, line: &str) {
        self.generated.push_str(line);
        self.generated.push_str("\n");
    }

    // {:<8} alligns the operands
    fn emit_instruction(&mut self, opcode: &str, operands: &str, comment: &str) {
        if self.emit_comments && !comment.is_empty() {
            self.generated.push_str(&format!(
                "        {:<8}{:<24}#{}\n",
                opcode, operands, comment
            ));
        } else {
            self.generated
                .push_str(&format!("        {:<8}{}\n", opcode, operands));
        }
    }

    fn emit_label(&mut self, label: &str) {
        self.generated.push_str(label);
        self.generated.push_str(":\n");
    }

    fn check_if_main_exists(&self) -> bool {
        // This is so much worse than just "hacky"
        for stmt in &self.program.segments.text.body {
            if let Statement::Function { name, .. } = stmt {
                if name == "main" {
                    return true;
                }
            }
        }

        false
    }

    fn generate_function(&mut self, function: &Statement) {
        if let Statement::Function {
            name,
            params,
            body,
            return_type: _,
            use_stack,
        } = function
        {
            if *use_stack {
                // Each function get its own allocator with its own stack frame
                let allocator = &mut Allocator::new();

                let stack_size = allocator.calculate_needed_stack_space(&body, params.len());

                self.emit_label(name);

                self.emit_instruction(
                    "addi",
                    &format!("$sp, $sp, -{}", stack_size),
                    &format!("Allocate {} bytes of stack space", stack_size),
                );
                allocator.add_stack_variable("$ra");

                // It's okay to unwrap here because we just added $ra
                self.emit_instruction(
                    "sw",
                    &format!(
                        "$ra, {}($sp)\n",
                        allocator.get_stack_variable_offset("$ra").unwrap()
                    ),
                    "Store the original return address on the stack",
                );

                for (i, param) in params.iter().enumerate() {
                    allocator.add_stack_variable(&param.name);
                    let param_reg = ["$a0", "$a1", "$a2", "$a3"][i];
                    let offset = allocator.get_stack_variable_offset(&param.name).unwrap();

                    self.emit_instruction(
                        "sw",
                        &format!("{}, {}($sp)", param_reg, offset),
                        &format!("Save parameter {} from {} to stack", param.name, param_reg),
                    );
                }

                for stmt in body {
                    self.generate_statement(&stmt, allocator);
                }
            } else {
                self.emit_label(name);

                for stmt in body {
                    self.generate_statement(&stmt, &mut Allocator::new());
                }
            }
        }
    }

    fn generate_function_call(
        &mut self,
        function_name: &String,
        arguments: &Vec<Argument>,
        is_builtin_function: &bool,
        builtin_function_type: &Option<BuiltinFunctionType>,
        allocator: &mut Allocator,
    ) {
        if *is_builtin_function {
            let syscall_number = match builtin_function_type {
                Some(BuiltinFunctionType::IntegerPrint) => 1,
                Some(BuiltinFunctionType::IntegerRead) => 5,
                Some(BuiltinFunctionType::StringRead) => 8,
                Some(BuiltinFunctionType::StringPrint) => 4,

                None => -1,
            };

            for arg in arguments {
                match &arg.expr {
                    Expr::Identifier(name) => {
                        let offset = self.get_offset_with_panic(allocator, &name);
                        self.emit_instruction(
                            "lw",
                            &format!("$a0, {}($sp)", offset),
                            &format!("Load argument {} into $a0 from {}($sp)", name, offset),
                        );
                    }

                    Expr::Integer(n) => {
                        self.emit_instruction(
                            "li",
                            &format!("$a0, {}", n),
                            &format!("Load {} into argument register $a0", n),
                        );
                    }

                    Expr::StringLiteral(s) => {
                        let label = match self.get_data_label_for_string(s) {
                            Some(l) => l,
                            None => {
                                panic!("Label not found for {}", s);
                            }
                        };

                        self.emit_instruction("la", &format!("$a0, {}", label), &format!("Load the address of the string stored at {} into argument register $a0", label));
                    }

                    _ => {
                        panic!(
                            "expr {:?} not implemented in generate_builtin_function",
                            arg.expr
                        );
                    }
                }
            }

            self.emit_instruction(
                "li",
                &format!("$v0, {}", syscall_number),
                &format!(
                    "Load the appropriate syscall number {} into $v0",
                    syscall_number
                ),
            );
            self.emit_instruction("syscall", "", "");
            self.emit("");
        }
    }

    fn generate_return(&mut self, expr: &Expr, allocator: &mut Allocator) {
        let mut reg = String::new();
        let mut include_return_register = true;

        match expr {
            Expr::Identifier(name) => {
                reg = match allocator.get_variable_register(name) {
                    Some(r) => r,
                    None => {
                        panic!(
                            "Register or Offset not found for {} in generate_return",
                            name
                        );
                    }
                };
            }

            Expr::Integer(n) => {
                let temp = match allocator.allocate_temp() {
                    Some(reg) => reg,
                    None => {
                        panic!("Out of temp registers in generate_condition_and_branch")
                    }
                };

                self.emit_instruction(
                    "li",
                    &format!("{}, {}", temp, n),
                    &format!("Load {} into temp register {}", temp, n),
                );
            }

            Expr::Empty => {
                include_return_register = false;
            }

            _ => {
                panic!("Expr {:?} not implemented in generate_return", expr);
            }
        }

        if include_return_register {
            if reg.contains("($sp)") {
                self.emit_instruction(
                    "lw",
                    &format!("$v0, {}", reg),
                    &format!("Load value at {} into return register", reg),
                );
            } else {
                self.emit_instruction(
                    "move",
                    &format!("$v0, {}", reg),
                    &format!("Move value from register {} to return register", reg),
                );
            }
        }

        self.emit_instruction(
            "lw",
            &format!(
                "$ra, {}($sp)",
                allocator.get_stack_variable_offset("$ra").unwrap()
            ),
            &format!(
                "Load stored return address from {}($sp) back into $ra",
                allocator.get_stack_variable_offset("$ra").unwrap()
            ),
        );

        self.emit_instruction(
            "addi",
            &format!("$sp, $sp, {}", allocator.get_stack_size()),
            &format!(
                "Deallocate {} bytes of stack space",
                allocator.get_stack_size()
            ),
        );
        self.emit_instruction("jr", "$ra\n", "Jump back to the function caller's address");
    }

    fn generate_statement(&mut self, statement: &Statement, allocator: &mut Allocator) {
        match statement {
            Statement::VariableDeclaration {
                var_type,
                identifier,
                operation,
            } => self.generate_variable_declaration(var_type, identifier, operation, allocator),

            Statement::VariableAssignment {
                identifier,
                operation,
            } => self.generate_variable_assignment(identifier, operation, allocator),

            Statement::Instruction { opcode, operands } => {
                self.emit_instruction(opcode, &operands.join(", "), "");
            }

            Statement::While {
                body_label,
                end_label,
                condition,
                body,
            } => {
                self.generate_while(body_label, end_label, condition, body, allocator);
            }

            Statement::For {
                init,
                body_label,
                end_label,
                condition,
                var_change,
                body,
            } => {
                self.generate_for(
                    init, body_label, end_label, condition, var_change, body, allocator,
                );
            }

            Statement::If {
                label,
                condition,
                body,
            } => {
                self.generate_if(label, condition, body, allocator);
            }

            Statement::Return { value } => {
                self.generate_return(value, allocator);
            }

            Statement::FunctionCall {
                function_name,
                arguments,
                is_builtin_function,
                builtin_function_type,
            } => {
                self.generate_function_call(
                    function_name,
                    arguments,
                    is_builtin_function,
                    builtin_function_type,
                    allocator,
                );
            }

            Statement::NewLine => {
                self.line += 1;
            }

            _ => {}
        }
    }

    // This function is a mess, so be careful
    // You might hurt your eyes reading it
    fn generate_variable_declaration(
        &mut self,
        var_type: &Type,
        identifier: &String,
        operation: &Expr,
        allocator: &mut Allocator,
    ) {
        allocator.add_stack_variable(identifier);

        match var_type {
            Type::Int32 => {
                if let Expr::BinaryOp {
                    left,
                    operator,
                    right,
                    is_not: _,
                } = operation
                {
                    // Only left, basic declaration
                    if *operator == BinaryOperator::Empty && **right == Expr::Empty {
                        let reg = match allocator.allocate_temp() {
                            Some(r) => r,
                            None => {
                                panic!("Ran out of temporary registers");
                            }
                        };

                        match &**left {
                            Expr::Integer(n) => {
                                self.emit_instruction(
                                    "li",
                                    &format!("{}, {}", reg, n),
                                    &format!("Load {} into register {}", n, reg),
                                );

                                self.emit_instruction(
                                    "sw",
                                    &format!(
                                        "{}, {}($sp)\n",
                                        reg,
                                        self.get_offset_with_panic(allocator, identifier)
                                    ),
                                    &format!(
                                        "Store {} from register {} into stack at {}($sp)",
                                        n,
                                        reg,
                                        self.get_offset_with_panic(allocator, identifier)
                                    ),
                                );

                                allocator.free_temp(reg);
                            }

                            Expr::Identifier(name) => {
                                self.emit_instruction(
                                    "lw",
                                    &format!(
                                        "{}, {}($sp)\n",
                                        reg,
                                        self.get_offset_with_panic(allocator, name)
                                    ),
                                    &format!(
                                        "Load value in variable {} from {}($sp) into register {}",
                                        name,
                                        self.get_offset_with_panic(allocator, name),
                                        reg
                                    ),
                                );

                                self.emit_instruction(
                                    "sw",
                                    &format!(
                                        "{}, {}($sp)\n",
                                        reg,
                                        self.get_offset_with_panic(allocator, identifier)
                                    ),
                                    &format!(
                                        "Store value from register {} into {}($sp)",
                                        reg,
                                        self.get_offset_with_panic(allocator, identifier)
                                    ),
                                );

                                allocator.free_temp(reg);
                            }

                            Expr::FunctionCall {
                                function_name,
                                arguments,
                                is_builtin_function,
                                builtin_function_type,
                            } => {
                                if arguments.len() > 4 {
                                    panic!("Maximum of 4 arguments allowed for {}", function_name);
                                }

                                let registers = ["$a0", "$a1", "$a2", "$a3"];

                                for i in 0..arguments.len() {
                                    match &arguments[i].expr {
                                        Expr::Integer(n) => {
                                            self.emit_instruction(
                                                "li",
                                                &format!("{}, {}", registers[i], n),
                                                &format!(
                                                    "Load {} into register {}",
                                                    n, registers[i]
                                                ),
                                            );
                                        }

                                        Expr::Identifier(name) => {
                                            let offset =
                                                self.get_offset_with_panic(allocator, &name);
                                            self.emit_instruction(
                                                "lw",
                                                &format!("{}, {}($sp)", registers[i], offset),
                                                &format!(
                                                    "Load value at {}($sp) into {}",
                                                    offset, registers[i]
                                                ),
                                            );
                                        }

                                        _ => {
                                            panic!(
                                                "Argument Expr {:?} not implemented in generate_variable_declaration",
                                                arguments[i].expr
                                            );
                                        }
                                    }
                                }

                                if *is_builtin_function {
                                    let syscall_number = match builtin_function_type {
                                        Some(BuiltinFunctionType::IntegerPrint) => 1,
                                        Some(BuiltinFunctionType::IntegerRead) => 5,
                                        Some(BuiltinFunctionType::StringRead) => 8,
                                        Some(BuiltinFunctionType::StringPrint) => 4,

                                        None => -1,
                                    };

                                    self.emit_instruction(
                                        "li",
                                        &format!("$v0, {}", syscall_number),
                                        "Load syscall number into $a0",
                                    );

                                    self.emit_instruction("syscall", "", "");
                                } else {
                                    self.emit_instruction(
                                        "jal",
                                        function_name,
                                        &format!("Call function {}", function_name),
                                    );
                                }

                                self.emit_instruction(
                                    "sw",
                                    &format!(
                                        "$v0, {}($sp)\n",
                                        self.get_offset_with_panic(allocator, identifier)
                                    ),
                                    &format!(
                                        "Store value in register $v0 into {}($sp)",
                                        self.get_offset_with_panic(allocator, identifier)
                                    ),
                                );
                            }

                            _ => {
                                panic!(
                                    "Expr {:?} not implemented in generate_variable_declaration",
                                    **left
                                );
                            }
                        }
                    } else {
                        let left_temp = match allocator.allocate_temp() {
                            Some(r) => r,
                            None => {
                                panic!("Ran out of temporary registers");
                            }
                        };

                        let right_temp = match allocator.allocate_temp() {
                            Some(r) => r,
                            None => {
                                panic!("Ran out of temporary registers");
                            }
                        };

                        match &**left {
                            Expr::Integer(n) => {
                                self.emit_instruction(
                                    "li",
                                    &format!("{}, {}", left_temp, n),
                                    &format!("Load {} into left register {}", n, left_temp),
                                );
                            }

                            Expr::Identifier(name) => {
                                let reg_option = allocator.get_variable_register(name);
                                match reg_option {
                                    Some(reg) => {
                                        self.emit_instruction(
                                            "lw",
                                            &format!("{}, {}", left_temp, reg),
                                            &format!(
                                                "Load value from {} into left register {}",
                                                reg, left_temp
                                            ),
                                        );
                                    }
                                    None => {
                                        panic!(
                                            "Register or Offset not found for {} in generate_variable_declaration",
                                            name
                                        );
                                    }
                                }
                            }

                            _ => {
                                panic!(
                                    "Expr {:?} not implemented in generate_variable_declaration",
                                    **left
                                );
                            }
                        }

                        match &**right {
                            Expr::Integer(n) => {
                                self.emit_instruction(
                                    "li",
                                    &format!("{}, {}", right_temp, n),
                                    &format!("Load {} into right register {}", n, right_temp),
                                );
                            }

                            Expr::Identifier(name) => {
                                let reg_option = allocator.get_variable_register(name);
                                match reg_option {
                                    Some(reg) => {
                                        self.emit_instruction(
                                            "lw",
                                            &format!("{}, {}", right_temp, reg),
                                            &format!(
                                                "Load value from {} into right register {}",
                                                reg, right_temp
                                            ),
                                        );
                                    }
                                    None => {
                                        panic!(
                                            "Register or Offset not found for {} in generate_variable_declaration",
                                            name
                                        );
                                    }
                                }
                            }

                            _ => {
                                panic!(
                                    "Expr {:?} not implemented in generate_variable_declaration",
                                    **right
                                );
                            }
                        }

                        let temp = match allocator.allocate_temp() {
                            Some(r) => r,
                            None => {
                                panic!("Ran out of temporary registers");
                            }
                        };

                        match operator {
                            BinaryOperator::Add => {
                                self.emit_instruction(
                                    "add",
                                    &format!("{}, {}, {}", temp, left_temp, right_temp),
                                    &format!(
                                        "Add values from {} and {} and store in register {}",
                                        left_temp, right_temp, temp
                                    ),
                                );
                            }

                            BinaryOperator::Subtract => {
                                self.emit_instruction(
                                    "sub",
                                    &format!("{}, {}, {}", temp, left_temp, right_temp),
                                    &format!(
                                        "Sub values from {} and {} and store in register {}",
                                        left_temp, right_temp, temp
                                    ),
                                );
                            }

                            _ => panic!("Unsupported binary operator: {:?}", operator),
                        }

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                temp,
                                self.get_offset_with_panic(allocator, identifier),
                            ),
                            &format!(
                                "Store value from register {} to {}($sp)",
                                temp,
                                self.get_offset_with_panic(allocator, identifier)
                            ),
                        );

                        allocator.free_temp(temp);
                        allocator.free_temp(left_temp);
                        allocator.free_temp(right_temp);
                    }
                }
            }

            Type::String => match operation {
                Expr::StringLiteral(str) => {
                    let reg = match allocator.allocate_temp() {
                        Some(r) => r,
                        None => {
                            panic!("Ran out of temporary registers");
                        }
                    };

                    let label = match self.get_data_label_for_string(str) {
                        Some(l) => l,
                        None => {
                            panic!("String literal {} not found in data segment", str);
                        }
                    };

                    self.emit_instruction(
                        "la",
                        &format!("{}, {}", reg, label),
                        &format!("Load string from address {} into register {}", label, reg),
                    );

                    self.emit_instruction(
                        "sw",
                        &format!(
                            "{}, {}($sp)\n",
                            reg,
                            self.get_offset_with_panic(allocator, identifier),
                        ),
                        &format!(
                            "Store string address from {} into {}($sp)",
                            reg,
                            self.get_offset_with_panic(allocator, identifier)
                        ),
                    );

                    allocator.free_temp(reg);
                }

                Expr::Identifier(name) => {
                    let reg = match allocator.allocate_temp() {
                        Some(r) => r,
                        None => {
                            panic!("Ran out of temporary registers");
                        }
                    };

                    let offset = match allocator.get_stack_variable_offset(name) {
                        Some(n) => n,
                        None => {
                            panic!("Variable {} not found in stack", name);
                        }
                    };

                    self.emit_instruction(
                        "lw",
                        &format!("{}, {}($sp)", reg, offset),
                        &format!("Load value from {}($sp) into register {}", offset, reg),
                    );

                    self.emit_instruction(
                        "sw",
                        &format!(
                            "{}, {}($sp)\n",
                            reg,
                            self.get_offset_with_panic(allocator, identifier),
                        ),
                        &format!(
                            "Store value from register {} into {}($sp)",
                            reg,
                            self.get_offset_with_panic(allocator, identifier)
                        ),
                    );

                    allocator.free_temp(reg);
                }

                _ => {
                    CompileError::TypeError {
                        message: "Unsupported expression in variable initialization".to_string(),
                        line: self.line,
                    };
                }
            },

            _ => {}
        }
    }

    // This one is ugly, I wrote this in a blur while I was super tired
    // I'm sorry
    fn generate_variable_assignment(
        &mut self,
        identifier: &String,
        operation: &Expr,
        allocator: &mut Allocator,
    ) {
        let reg = match allocator.allocate_temp() {
            Some(r) => r,
            None => {
                panic!("Ran out of temporary registers");
            }
        };

        match operation {
            Expr::Integer(value) => {
                self.emit_instruction(
                    "li",
                    &format!("{}, {}", reg, value),
                    &format!("Load {} into register {}", value, reg),
                );

                self.emit_instruction(
                    "sw",
                    &format!(
                        "{}, {}($sp)\n",
                        reg,
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                    &format!(
                        "Store value from register {} into {}($sp)",
                        reg,
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                );

                allocator.free_temp(reg);
            }

            Expr::Identifier(name) => {
                let offset = match allocator.get_stack_variable_offset(name) {
                    Some(n) => n,
                    None => {
                        panic!("Variable {} not found in stack", name);
                    }
                };

                self.emit_instruction(
                    "lw",
                    &format!("{}, {}($sp)", reg, offset),
                    &format!("Load value at {}($sp) into register {}", offset, reg),
                );

                self.emit_instruction(
                    "sw",
                    &format!(
                        "{}, {}($sp)\n",
                        reg,
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                    &format!(
                        "Store value from register {} into {}($sp)",
                        reg,
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                );

                allocator.free_temp(reg);
            }

            Expr::FunctionCall {
                function_name,
                arguments,
                is_builtin_function,
                builtin_function_type,
            } => {
                if arguments.len() > 4 {
                    panic!("Maximum of 4 arguments allowed for {}", function_name);
                }

                let registers = ["$a0", "$a1", "$a2", "$a3"];

                for i in 0..arguments.len() {
                    match &arguments[i].expr {
                        Expr::Integer(n) => {
                            self.emit_instruction(
                                "li",
                                &format!("{}, {}", registers[i], n),
                                &format!("Load {} into register {}", n, registers[i]),
                            );
                        }

                        Expr::Identifier(name) => {
                            let offset = self.get_offset_with_panic(allocator, &name);
                            self.emit_instruction(
                                "lw",
                                &format!("{}, {}($sp)", registers[i], offset),
                                &format!("Load value at {}($sp) into {}", offset, registers[i]),
                            );
                        }

                        _ => {
                            panic!(
                                "Argument Expr {:?} not implemented in generate_variable_assignment",
                                arguments[i].expr
                            );
                        }
                    }
                }

                if *is_builtin_function {
                    let syscall_number = match builtin_function_type {
                        Some(BuiltinFunctionType::IntegerPrint) => 1,
                        Some(BuiltinFunctionType::IntegerRead) => 5,
                        Some(BuiltinFunctionType::StringRead) => 8,
                        Some(BuiltinFunctionType::StringPrint) => 4,
                        None => -1,
                    };

                    self.emit_instruction(
                        "li",
                        &format!("$v0, {}", syscall_number),
                        "Load syscall number into $v0",
                    );

                    self.emit_instruction("syscall", "", "");
                } else {
                    self.emit_instruction(
                        "jal",
                        function_name,
                        &format!("Call function {}", function_name),
                    );
                }

                self.emit_instruction(
                    "sw",
                    &format!(
                        "$v0, {}($sp)",
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                    &format!(
                        "Store return value from $v0 into {}($sp)",
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                );

                self.emit("");
                allocator.free_temp(reg);
            }

            Expr::BinaryOp {
                left,
                operator,
                right,
                is_not: _,
            } => {
                match &**left {
                    Expr::Identifier(name) => {
                        let offset = self.get_offset_with_panic(allocator, name);
                        self.emit_instruction(
                            "lw",
                            &format!("{}, {}($sp)", reg, offset),
                            &format!(
                                "Load value from {}($sp) (variable {}) into left register {}",
                                name, offset, reg
                            ),
                        );
                    }
                    Expr::Integer(value) => {
                        self.emit_instruction(
                            "li",
                            &format!("{}, {}", reg, value),
                            &format!("Load {} into register {}", value, reg),
                        );
                    }
                    _ => panic!("Unsupported left operand in binary operation"),
                }

                let reg2 = match allocator.allocate_temp() {
                    Some(r) => r,
                    None => panic!("Ran out of temporary registers"),
                };

                match &**right {
                    Expr::Identifier(name) => {
                        let right_r = match allocator.get_variable_register(name) {
                            Some(r) => r,
                            None => {
                                panic!(
                                    "Register or Offset not found for {} in generate_variable_assignment",
                                    name
                                );
                            }
                        };

                        if right_r.contains("($sp)") {
                            let offset = self.get_offset_with_panic(allocator, name);
                            self.emit_instruction(
                                "lw",
                                &format!("{}, {}($sp)", reg2, offset),
                                &format!(
                                    "Load value from {}($sp) (variable {}) into right register {}",
                                    name, offset, reg2
                                ),
                            );
                        } else {
                            self.emit_instruction(
                                "move",
                                &format!("{}, {}", reg2, right_r),
                                &format!(
                                    "Load value from {} (variable {}) into right register {}",
                                    name, right_r, reg2
                                ),
                            );
                        }
                    }
                    Expr::Integer(value) => {
                        self.emit_instruction(
                            "li",
                            &format!("{}, {}", reg2, value),
                            &format!("Load {} into register {}", value, reg2),
                        );
                    }

                    Expr::FunctionCall {
                        function_name,
                        arguments,
                        is_builtin_function,
                        builtin_function_type,
                    } => {
                        if arguments.len() > 4 {
                            panic!("Maximum of 4 arguments allowed for {}", function_name);
                        }

                        let registers = ["$a0", "$a1", "$a2", "$a3"];

                        for i in 0..arguments.len() {
                            match &arguments[i].expr {
                                Expr::Integer(n) => {
                                    self.emit_instruction(
                                        "li",
                                        &format!("{}, {}", registers[i], n),
                                        &format!("Load {} into register {}", n, registers[i]),
                                    );
                                }

                                Expr::Identifier(name) => {
                                    let offset = self.get_offset_with_panic(allocator, &name);
                                    self.emit_instruction(
                                        "lw",
                                        &format!("{}, {}($sp)", registers[i], offset),
                                        &format!(
                                            "Load value at {}($sp) into {}",
                                            offset, registers[i]
                                        ),
                                    );
                                }

                                _ => {
                                    panic!(
                                        "Argument Expr {:?} not implemented in generate_variable_assignment",
                                        arguments[i].expr
                                    );
                                }
                            }
                        }

                        if *is_builtin_function {
                            let syscall_number = match builtin_function_type {
                                Some(BuiltinFunctionType::IntegerPrint) => 1,
                                Some(BuiltinFunctionType::IntegerRead) => 5,
                                Some(BuiltinFunctionType::StringRead) => 8,
                                Some(BuiltinFunctionType::StringPrint) => 4,
                                None => -1,
                            };

                            self.emit_instruction(
                                "li",
                                &format!("$v0, {}", syscall_number),
                                "Load syscall number into $v0",
                            );

                            self.emit_instruction("syscall", "", "");
                        } else {
                            self.emit_instruction(
                                "jal",
                                function_name,
                                &format!("Call function {}", function_name),
                            );
                        }

                        self.emit_instruction(
                            "move",
                            &format!("{}, $v0", reg2),
                            &format!("Move return value from $v0 to {}", reg2),
                        );
                    }
                    _ => panic!("Unsupported right operand in binary operation"),
                }

                match operator {
                    BinaryOperator::Add => {
                        self.emit_instruction("add", &format!("{}, {}, {}", reg, reg, reg2), &format!("Add values from register {} and {} and store it back into register {}", reg, reg2, reg));
                    }

                    BinaryOperator::Subtract => {
                        self.emit_instruction("sub", &format!("{}, {}, {}", reg, reg, reg2), &format!("Sub values from register {} and {} and store it back into register {}", reg, reg2, reg));
                    }

                    _ => panic!("Unsupported binary operator: {:?}", operator),
                }

                self.emit_instruction(
                    "sw",
                    &format!(
                        "{}, {}($sp)",
                        reg,
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                    &format!(
                        "Store value from register {} into {}($sp)",
                        reg,
                        self.get_offset_with_panic(allocator, identifier)
                    ),
                );

                self.emit("");

                allocator.free_temp(reg2);
                allocator.free_temp(reg);
            }

            _ => {
                CompileError::TypeError {
                    message: "Unsupported expression in variable assignment".to_string(),
                    line: self.line,
                };
            }
        }
    }

    fn generate_condition_and_branch(
        &mut self,
        condition: &Expr,
        branch_label: &String,
        allocator: &mut Allocator,
    ) {
        if let Expr::BinaryOp {
            left,
            operator,
            right,
            is_not,
        } = condition
        {
            let branch_type = match (operator, *is_not) {
                (BinaryOperator::LessThan, true) => "bge",
                (BinaryOperator::LessThan, false) => "blt",
                (BinaryOperator::LessEqual, true) => "bgt",
                (BinaryOperator::LessEqual, false) => "ble",
                (BinaryOperator::GreaterThan, true) => "ble",
                (BinaryOperator::GreaterThan, false) => "bgt",
                (BinaryOperator::Equal, true) => "bne",
                (BinaryOperator::Equal, false) => "beq",
                (BinaryOperator::NotEqual, true) => "beq",
                (BinaryOperator::NotEqual, false) => "bne",

                _ => panic!(
                    "{:?} not implemented in generate_condition_and_branch",
                    operator
                ),
            };

            let left_reg = match allocator.allocate_temp() {
                Some(reg) => reg,
                None => {
                    panic!("Out of temp registers in generate_condition_and_branch")
                }
            };

            let right_reg = match allocator.allocate_temp() {
                Some(reg) => reg,
                None => {
                    panic!("Out of temp registers in generate_condition_and_branch")
                }
            };

            match &**left {
                Expr::Identifier(name) => {
                    let location = allocator.get_variable_location(name);
                    if location == VariableLocation::Stack {
                        let offset = match allocator.get_stack_variable_offset(name) {
                            Some(n) => n,
                            None => {
                                panic!("Variable {} doesn't have offset", name);
                            }
                        };

                        self.emit_instruction(
                            "lw",
                            &format!("{}, {}($sp)", left_reg, offset),
                            &format!(
                                "Load value from {}($sp) into left register {}",
                                offset, left_reg
                            ),
                        );
                    } else {
                        let reg = match allocator.get_argument_register(name) {
                            Some(r) => r,
                            None => {
                                panic!("Argument register not found for {}", name);
                            }
                        };

                        self.emit_instruction(
                            "move",
                            &format!("{}, {}", left_reg, reg),
                            &format!(
                                "Move value from register {} into left register {}",
                                reg, left_reg
                            ),
                        );
                    }
                }

                Expr::Integer(n) => {
                    self.emit_instruction(
                        "li",
                        &format!("{}, {}", left_reg, n),
                        &format!("Store {} in left register {}", n, left_reg),
                    );
                }

                _ => {}
            }

            match &**right {
                Expr::Identifier(name) => {
                    let location = allocator.get_variable_location(name);
                    if location == VariableLocation::Stack {
                        let offset = match allocator.get_stack_variable_offset(name) {
                            Some(n) => n,
                            None => {
                                panic!("Variable {} doesn't have offset", name);
                            }
                        };

                        self.emit_instruction(
                            "lw",
                            &format!("{}, {}($sp)", right_reg, offset),
                            &format!(
                                "Load value from {}($sp) into right register {}",
                                offset, right_reg
                            ),
                        );
                    } else {
                        let reg = match allocator.get_argument_register(name) {
                            Some(r) => r,
                            None => {
                                panic!("Argument register not found for {}", name);
                            }
                        };

                        self.emit_instruction(
                            "move",
                            &format!("{}, {}", right_reg, reg),
                            &format!(
                                "Move value from register {} into right register {}",
                                reg, right_reg
                            ),
                        );
                    }
                }

                Expr::Integer(n) => {
                    self.emit_instruction(
                        "li",
                        &format!("{}, {}", right_reg, n),
                        &format!("Load {} into right register {}", n, right_reg),
                    );
                }

                _ => {}
            }

            self.emit_instruction(
                branch_type,
                &format!("{}, {}, {}", left_reg, right_reg, branch_label),
                &format!("Compare values at left register {} and right register {} and branch to {} if needed", left_reg, right_reg, branch_label)
            );

            self.emit("");
            allocator.free_temp(left_reg);
            allocator.free_temp(right_reg);
        }
    }

    fn generate_while(
        &mut self,
        body_label: &String,
        end_label: &String,
        condition: &Expr,
        body: &Vec<Statement>,
        allocator: &mut Allocator,
    ) {
        self.emit_instruction(
            "j",
            end_label,
            &format!("Jump to while loop end at label {}", end_label),
        );
        self.emit_label(body_label);

        for stmt in body {
            self.generate_statement(stmt, allocator);
        }

        self.emit_label(end_label);

        self.generate_condition_and_branch(condition, body_label, allocator);
    }

    fn generate_for(
        &mut self,
        init: &Box<Statement>,
        body_label: &String,
        end_label: &String,
        condition: &Expr,
        var_change: &Box<Statement>,
        body: &Vec<Statement>,
        allocator: &mut Allocator,
    ) {
        if let Statement::VariableDeclaration {
            var_type,
            identifier,
            operation,
        } = &**init
        {
            self.generate_variable_declaration(var_type, identifier, operation, allocator);
        }

        self.emit_instruction(
            "j",
            end_label,
            &format!("Jump to for loop end at label {}", end_label),
        );

        self.emit("");
        self.emit_label(body_label);

        for stmt in body {
            self.generate_statement(stmt, allocator);
        }

        if let Statement::VariableAssignment {
            identifier,
            operation,
        } = &**var_change
        {
            self.generate_variable_assignment(identifier, operation, allocator);
        }

        self.emit_label(end_label);

        self.generate_condition_and_branch(condition, body_label, allocator);
    }

    fn generate_if(
        &mut self,
        label: &String,
        condition: &Expr,
        body: &Vec<Statement>,
        allocator: &mut Allocator,
    ) {
        self.generate_condition_and_branch(condition, label, allocator);

        for stmt in body {
            self.generate_statement(stmt, allocator);
        }

        self.emit_label(label);
    }

    // fn generate_builtin_function(
    //     &mut self,
    //     function_type: &BuiltinFunctionType,
    //     arguments: &Vec<Argument>,
    //     allocator: &mut Allocator,
    // ) {
    //     let syscall_number = match function_type {
    //         BuiltinFunctionType::IntegerPrint => 1,
    //         BuiltinFunctionType::StringPrint => 4,
    //         BuiltinFunctionType::IntegerRead => 5,
    //         BuiltinFunctionType::StringRead => 8,
    //     };

    //     // Looping through the arguments here is kinda useless because
    //     // We're only using a0 I think it's fine for now
    //     for arg in arguments {
    //         match &arg.expr {
    //             Expr::Identifier(name) => {
    //                 let offset = self.get_offset_with_panic(allocator, &name);
    //                 self.emit_instruction(
    //                     "lw",
    //                     &format!("$a0, {}($sp)", offset),
    //                     &format!("Load argument {} into $a0 from {}($sp)", name, offset),
    //                 );
    //             }

    //             Expr::Integer(n) => {
    //                 self.emit_instruction(
    //                     "li",
    //                     &format!("$a0, {}", n),
    //                     &format!("Load {} into argument register $a0", n),
    //                 );
    //             }

    //             Expr::StringLiteral(s) => {
    //                 let label = match self.get_data_label_for_string(s) {
    //                     Some(l) => l,
    //                     None => {
    //                         panic!("Label not found for {}", s);
    //                     }
    //                 };

    //                 self.emit_instruction("la", &format!("$a0, {}", label), &format!("Load the address of the string stored at {} into argument register $a0", label));
    //             }

    //             _ => {
    //                 panic!(
    //                     "expr {:?} not implemented in generate_builtin_function",
    //                     arg.expr
    //                 );
    //             }
    //         }
    //     }

    //     self.emit_instruction(
    //         "li",
    //         &format!("$v0, {}", syscall_number),
    //         &format!(
    //             "Load the appropriate syscall number {} into $v0",
    //             syscall_number
    //         ),
    //     );
    //     self.emit_instruction("syscall", "", "");
    //     self.emit("");
    // }

    fn generate_data_label(&mut self, statement: &Statement) {
        if let Statement::DataDeclaration {
            label,
            storage_type,
            value,
        } = statement
        {
            match storage_type {
                DataStorageType::Asciiz => {
                    self.emit(&format!("\t{}: .asciiz \"{}\"", label, value));
                }
            }
        }
    }

    fn get_data_label_for_string(&self, value: &String) -> Option<String> {
        for stmt in &self.program.segments.data.body {
            if let Statement::DataDeclaration {
                label,
                storage_type: DataStorageType::Asciiz,
                value: val,
            } = stmt
            {
                if val == value {
                    return Some(label.clone());
                }
            }
        }

        None
    }

    // Needs to be changed in the future
    fn get_offset_with_panic(&self, allocator: &Allocator, name: &String) -> usize {
        match allocator.get_stack_variable_offset(name) {
            Some(n) => n,
            None => {
                panic!("Variable {} not found in stack", name);
            }
        }
    }
}
