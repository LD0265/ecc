mod allocator;

// Expect to see a lot of comments here
// This might just be the messiest file
// But that's fine because I'm awesome

use crate::{
    error::CompileError,
    mips::allocator::Allocator,
    parser::ast::{Expr, Program, Statement, Type},
};

pub struct MipsGenerator {
    program: Program,
    generated: String,
}

impl MipsGenerator {
    pub fn new(program: Program) -> Self {
        MipsGenerator {
            program,
            generated: String::new(),
        }
    }

    pub fn generate(&mut self) -> Result<&String, CompileError> {
        // This feels hacky
        if !self.check_if_main_exists() {
            return Err(CompileError::CodeGenError {
                message: "No main function found".to_string(),
                line: 0,
            });
        }

        self.init();

        let statements = self.program.statements.clone();
        for stmt in &statements {
            match stmt {
                Statement::Function { .. } => self.generate_function(stmt),
                _ => {}
            }
        }

        Ok(&self.generated)
    }

    fn init(&mut self) {
        self.emit("# Assembly generated by ecc (Evil C Compiler)\n");

        // I should really add _start to the AST
        // But I can get by with this
        self.emit(".text");
        self.emit(".globl _start");
        self.emit("");

        // Assume that main exists
        self.emit_label("_start");
        self.emit_instruction("jal", "main");

        // 10 is the exit syscall
        self.emit_instruction("li", "$v0, 10");
        self.emit_instruction("syscall", "");
        self.emit("");
    }

    fn emit(&mut self, line: &str) {
        self.generated.push_str(line);
        self.generated.push_str("\n");
    }

    // {:<8} alligns the operands
    fn emit_instruction(&mut self, opcode: &str, operands: &str) {
        self.generated
            .push_str(&format!("        {:<8}{}\n", opcode, operands));
    }

    fn emit_label(&mut self, label: &str) {
        self.generated.push_str(label);
        self.generated.push_str(":\n");
    }

    fn check_if_main_exists(&self) -> bool {
        for stmt in &self.program.statements {
            if let Statement::Function { name, .. } = stmt {
                if name == "main" {
                    return true;
                }
            }
        }

        false
    }

    fn generate_function(&mut self, function: &Statement) {
        if let Statement::Function {
            name,
            params,
            body,
            return_type,
        } = function
        {
            // Each function get its own allocator with its own stack frame
            let allocator = &mut Allocator::new();

            let stack_size = allocator.calculate_needed_stack_space(&body);

            self.emit_label(name);

            self.emit_instruction("addi", &format!("$sp, $sp, -{}", stack_size));
            allocator.add_stack_variable("$ra");

            // It's okay to unwrap here because we just added $ra
            self.emit_instruction(
                "sw",
                &format!(
                    "$ra, {}($sp)\n",
                    allocator.get_stack_variable_offset("$ra").unwrap()
                ),
            );
            for stmt in body {
                self.generate_statement(&stmt, allocator);
            }

            self.emit_instruction(
                "lw",
                &format!(
                    "$ra, {}($sp)",
                    allocator.get_stack_variable_offset("$ra").unwrap()
                ),
            );
            self.emit_instruction("addi", &format!("$sp, $sp, {}\n", stack_size));
            self.emit_instruction("jr", "$ra\n");
        }
    }

    fn generate_statement(&mut self, statement: &Statement, allocator: &mut Allocator) {
        match statement {
            Statement::VariableDeclaration {
                var_type,
                identifier,
                init,
            } => self.generate_variable_declaration(var_type, identifier, init, allocator),

            _ => {}
        }
    }

    // This function is a mess, so be careful
    // You might hurt your eyes reading it
    fn generate_variable_declaration(
        &mut self,
        var_type: &Type,
        identifier: &String,
        init: &Option<Expr>,
        allocator: &mut Allocator,
    ) {
        allocator.add_stack_variable(identifier);

        if let Some(expr) = init {
            let reg = match allocator.allocate_temp() {
                Some(r) => r,
                None => {
                    panic!("Ran out of temporary registers");
                }
            };

            match var_type {
                Type::Int32 => match expr {
                    Expr::Integer(value) => {
                        self.emit_instruction("li", &format!("{} {}", reg.to_string(), value));

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                reg.to_string(),
                                allocator.get_stack_variable_offset(identifier).unwrap()
                            ),
                        );

                        allocator.free_temp(reg);
                    }

                    Expr::Identifier(name) => {
                        let offset = match allocator.get_stack_variable_offset(name) {
                            Some(n) => n,
                            None => {
                                panic!("Variable {} not found in stack", name);
                            }
                        };

                        self.emit_instruction("lw", &format!("{}, {}($sp)", reg.to_string(), offset));

                        self.emit_instruction(
                            "sw",
                            &format!(
                                "{}, {}($sp)\n",
                                reg.to_string(),
                                allocator.get_stack_variable_offset(identifier).unwrap()
                            ),
                        );

                        allocator.free_temp(reg);
                    }

                    _ => {
                        CompileError::TypeError {
                            message: "Unsupported expression in variable initialization"
                                .to_string(),
                            line: 0,
                        };
                    }
                },
                _ => panic!("Unsupported variable type"),
            }
        }
    }
}
